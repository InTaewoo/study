## 쿠버네티스와 같은 시스템이 필요한 이유
- 모놀리스 애플리케이션 에서 마이크로서비스로 전환
  - 마이크로서비스 애플리케이션 분할
  - 마이크로서비스 확장
  - 마이크로서비스 배포

- 애플리케이션에서 일괄된 환경 제공
  - 개발자와 운영팀이 항상 해결해야 하는 문제 중 하나가 실행하는 환경이 다르다는 것

- 지속적인 배포로 전환: 데브옵스와 노옵스
  - 개발자, 품질 보증, 운영 팀이 전체 프로세스에 협업해야 한다는 의미.
  - 데브옵스의 장점 : 개발자가 운영 팀에서 관리하는 프로덕션 환경에서 애플리케이션을 실행하는데 더 많이 관여 한다면 사용자가 무엇을 필요로 하고 어떤 문제가 있는지 잘 이해할 수 있음

## 컨테이너 기술 소개
- 리눅스 컨테이너 기술로 구성 요소 격리
  - 동일한 시스템에서 여러 개의 서비스를 실행할 수 있으며 동시에 서로 다른 환경을 만들어줄 뿐만 아니라 가상머신과 유사하게 서로 격리하지만 오버헤드가 훨씬 적음
- 컨테이너와 가상머신 비교
  - 컨테이너가 가상머신에 비해 훨씬 더 가벼워서 동일한 하드웨어에서 더 많은 수의 소프트웨어 구성 요소를 실행할 수 있다.
  - 컨테이너를 사용하면 애플리케이션 마다 하나의 컨테이너를 가질 수 있고 동일한 베어메탈 머신에서 더 많은 애플리케이션을 적재 할 수 있다.

 ![image](https://user-images.githubusercontent.com/81672260/147433952-252318c2-be67-4c8e-bbf3-e2b0997d9d23.png)

## 컨테이너 격리를 가능하게 하는 메커니즘 소개
- 리눅스 네임스페이스(namespace)로 각 프로세스가 시스템(파일,프로세스,네트워크,인터페이스,호스트 이름 등)에 대한 독립된 뷰만 볼 수 있도록 한다.
- 리눅스 컨트롤 그룹으로, 프로세스가 사용할 수 있는 리소스의 양을 제한한다.

## 리눅스 네임스페이스로 프로세스 격리
- 각 리눅스 시스템은 초기 구동시 하나의 네임스페이스가 있다.
- 네임스페이스의 종류
  - 마운트(mnt)
  - 프로세스 ID(pid)
  - 네트워크(net)
  - 프로세스 간 통신(ipc)
  - 호스트와 도메인 이름(uts)
  - 사용자 ID(user)

## 도커 이미지의 빌드, 배포, 실행
1. 개발자는 도커에게 이미지를 빌드하고 푸시하라고 명령한다.
2. 도커는 이미지를 빌드한다.
3. 도커는 이미지를 레지스트리에 푸시한다.
4. 개발자는 프로덕션 머신의 도커에게 이미지를 실행하라고 명령한다.
5. 도커는 레지스트리에서 이미지를 가져온다.
6. 도커는 이미지로부터 컨테이너를 실행한다.

![image](https://user-images.githubusercontent.com/81672260/147526965-a6677a74-3aab-42bb-80e4-de3922e8174f.png)

## 쿠버네티스 소개
구글은 시스템에 배포 가능한 애플리케이션 구성 요소의 수가 많아짐에 따라 모든 구성 요소의 관리가 더 어려워지는 것을 알았고 2014년 출시함.

- 쿠버네티스 핵심 이해
시스템은 마스터(master)노드와 여러 워커(worker)노드로 구성된다. 개발자는 특정 애플리케이션이 함께 실행되도록 지정할 수도 있으며    쿠버네티스는 여러 애플리케이션을 동일한 워커 노드에 배포한다.
![image](https://user-images.githubusercontent.com/81672260/147528088-170266a8-8f03-4280-818b-cd27b7455a11.png)
▲ 쿠버네티스는 전체 데이터 센터를 하나의 배포 플랫폼으로 제공한다.

- 개발자가 애플리케이션 핵심 기능에 집중할 수 있도록 지원
개발자가 특정 인프라 관련 서비스를 애플리케이션에 구현하지 않아도 되지만 `서비스 디스커버리, 스케일링, 로드밸런싱, 자가 치유, 리더 선출` 같은 것들이 포함된다.
따라서 개발자는 애플리케이션의 실제 기능을 구현하는 데 집중할 수 있다.

## 쿠버네티스 클러스터 아키텍처 이해
쿠버네티스 클러스터는 여러 노드로 구성되며, 두 가지 유형으로 나눌 수 있다.
- 마스터 노드는 전체 쿠버네티스 시스템을 제어하고 관리하는 쿠버네티스 컨트롤플레인을 실행한다.
- 워커노드는 실제 배포되는 컨테이너 애플리케이션을 실행한다.

![image](https://user-images.githubusercontent.com/81672260/147528703-5fb122ef-a96a-4362-b6f4-2c33ccefb1c3.png)
▲ 쿠버네티스 클러스터를 구성하는 구성 요소

## 컨트롤 플레인
컨트롤 플레인은 클러스터를 제어하고 작동시킨다. 하나의 마스터 노드에서 실행하거나 여러 노드로 분할되고 복제돼 고가용성을 보장할 수 있는 여러 구성 요소로 구성된다.

- 쿠버네티스 API서버는 사용자, 컨트롤 플레인 구성 요소와 통신한다.
- 스케줄러는 애플리케이션의 배포를 담당한다.
- 컨트롤러 매니저는 구성 요소 복제본, 워커 노드 추적, 노드 장애 처리 등과 같은 클러스터단의 기능을 수행한다.
- Etcd는 클러스터 구성을 지속적으로 저장하는 신뢰할 수 있는 분산 데이터 저장소다.

## 노드(Node)
워커 노드는 컨테이너화된 애플리케이션을 실행하는 시스템이다. 애플리케이션을 실행하고 모니터링하며 애플리케이션에 서비스를 제공하는 작업은 다음 구성 요소에 의해 수행된다.
- 컨테이너를 실행하는 도커, rkt또는 다른 컨테이너 런타임
- API서버와 통신하고 노드의 컨테이너를 관리하는 Kubelet
- 애플리케이션 구성 요소 간애 네트워크 트래픽을 로드밸런싱하는 쿠버네티스 서비스 프록시(kube-proxy)

## 쿠버네티스에서 애플리케이션 실행
- 쿠버네티스에서 애플리케이션을 실행하려면 먼저 애플리케이션 하나 이상의 컨테이너 이미지로 패키징하고 해당 이미지를 레지스트리로 푸시한 다음    
API서버에 애플리케이션 디스크립션을 게시해야 한다.

![image](https://user-images.githubusercontent.com/81672260/147529973-32141e56-ac91-45ab-a9da-7e7b12b02f1e.png)
- 애플리케이션 디스크립터는 3개 세트로 그룹화된 네 개의 컨테이너를 가진다.
- 즉, 두 컨테이너를 함께 배치해야 하며 서로 격리해서는 안 된다.


## 요약

1. 모놀리스 애플리케이션은 구축하기는 쉽지만 시간이 지남에 따라 유지 관리하기가 더 어려워지고 때로는 확장이 불가능할 수 있다.
2. 마이크로서비스 기반 애플리케이션 아키텍처는 각 구성 요소의 개발을 용이하게 하지만 하나의 시스템으로 작동하도록 배포하고 구성하기가 어렵다.
3. 리눅스 컨테이너는 가상머신과 동일한 이점을 제공하지만 훨씬 더 가볍고 하드웨어 활용도를 높일 수 있다.
4. 도커는 OS 환경과 함께 컨테이너화된 애플리케이션을 좀 더 쉽고 빠르게 프로비저닝할 수 있도록 지원해 기존 리눅스 컨테이너 기술을 개선했다.
5. 쿠버네티스는 전체 데이터 센터를 애플리케이션 실행을 위한 컴퓨팅 리소스로 제공한다.
6. 개발자는 시스템 관리자의 도움 없이도 쿠버네티스로 애플리케이션을 배포할 수 있다.
7. 시스템 관리자는 쿠버네티스가 고장 난 노드를 자동으로 처리하도록 함으로써 더 편하게 잠을 잘 수 있다.
